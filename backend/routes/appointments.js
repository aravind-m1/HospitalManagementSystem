const express = require('express');const router = express.Router();const Appointment = require('../models/Appointment');const Doctor = require('../models/Doctor');const auth = require('../middleware/auth');router.get('/', auth, async (req, res) => {  try {    const appointments = await Appointment.find()      .populate('doctorId', 'name specialization')      .sort({ date: 1, time: 1 });    res.json(appointments);  } catch (error) {    res.status(500).json({ message: error.message });  }});router.get('/doctor/:doctorId', auth, async (req, res) => {  try {    const appointments = await Appointment.find({ doctorId: req.params.doctorId })      .populate('doctorId', 'name specialization')      .sort({ date: 1, time: 1 });    res.json(appointments);  } catch (error) {    res.status(500).json({ message: error.message });  }});router.get('/patient/:patientName', auth, async (req, res) => {  try {    const appointments = await Appointment.find({      patientName: { $regex: req.params.patientName, $options: 'i' }    })      .populate('doctorId', 'name specialization')      .sort({ date: 1, time: 1 });    res.json(appointments);  } catch (error) {    res.status(500).json({ message: error.message });  }});router.post('/', auth, async (req, res) => {  try {    const doctor = await Doctor.findById(req.body.doctorId);    if (!doctor) {      return res.status(404).json({ message: 'Doctor not found' });    }    const conflictingAppointment = await Appointment.findOne({      doctorId: req.body.doctorId,      date: req.body.date,      time: req.body.time,      status: 'scheduled'    });    if (conflictingAppointment) {      return res.status(400).json({ message: 'Time slot is already booked' });    }    const appointment = new Appointment({      patientName: req.body.patientName,      doctorId: req.body.doctorId,      date: req.body.date,      time: req.body.time,      reason: req.body.reason,      notes: req.body.notes    });    const newAppointment = await appointment.save();    await newAppointment.populate('doctorId', 'name specialization');    res.status(201).json(newAppointment);  } catch (error) {    res.status(400).json({ message: error.message });  }});router.put('/:id', auth, async (req, res) => {  try {    const appointment = await Appointment.findById(req.params.id);    if (!appointment) {      return res.status(404).json({ message: 'Appointment not found' });    }    if (req.body.date && req.body.time) {      const conflictingAppointment = await Appointment.findOne({        doctorId: appointment.doctorId,        date: req.body.date,        time: req.body.time,        status: 'scheduled',        _id: { $ne: req.params.id }      });      if (conflictingAppointment) {        return res.status(400).json({ message: 'Time slot is already booked' });      }    }    Object.assign(appointment, req.body);    const updatedAppointment = await appointment.save();    await updatedAppointment.populate('doctorId', 'name specialization');    res.json(updatedAppointment);  } catch (error) {    res.status(400).json({ message: error.message });  }});router.delete('/:id', auth, async (req, res) => {  try {    const appointment = await Appointment.findById(req.params.id);    if (!appointment) {      return res.status(404).json({ message: 'Appointment not found' });    }    await appointment.remove();    res.json({ message: 'Appointment deleted' });  } catch (error) {    res.status(500).json({ message: error.message });  }});router.get('/available/:doctorId/:date', auth, async (req, res) => {  try {    const { doctorId, date } = req.params;    const appointments = await Appointment.find({      doctorId,      date,      status: 'scheduled'    }).select('time');    const timeSlots = [];    for (let hour = 9; hour < 17; hour++) {      for (let minute of ['00', '30']) {        timeSlots.push(`${hour.toString().padStart(2, '0')}:${minute}`);      }    }    const bookedSlots = appointments.map(apt => apt.time);    const availableSlots = timeSlots.filter(slot => !bookedSlots.includes(slot));    res.json(availableSlots);  } catch (error) {    res.status(500).json({ message: error.message });  }});module.exports = router; 